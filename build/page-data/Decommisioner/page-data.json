{"componentChunkName":"component---src-templates-blog-post-js","path":"/Decommisioner/","webpackCompilationHash":"49226d8a7396f9c20661","result":{"data":{"site":{"siteMetadata":{"title":"https://thomasleonhighbaugh.me","author":"Thomas Leon Highbaugh"}},"markdownRemark":{"id":"1f3d33b9-f38f-54f2-8033-4e0ed465ae0e","excerpt":"BASH-inception The Answer to Package Installation on Virtual Systems When provisioning virtual systems, it is often the case that there will be a precise set of…","html":"<h3>BASH-inception</h3>\n<h2>The Answer to Package Installation on Virtual Systems</h2>\n<p>When provisioning virtual systems, it is often the case that there will be a precise set of packages you wish to install on that virtual system to achieve whatever task it is you are using the system for. Remembering a long list of packages is often rather hard, especially when your primary focus is that task that you are doing with those virtual systems. While Docker images are a possible way around this dilemma, there are times when containers are simply not enough and you need the entire virtualized system, which is why I wrote this script. </p>\n<h4>Other Use Cases</h4>\n<p>This script is also useful in the situation where I want to install the precise packages that are currently installed on my OS that include some not reflected in my auto-installation programs (or in an Ansible playlist if that is your thing). </p>\n<p>It can also be useful when you achieve that perfect workstation configuration and want a back up for later installation. </p>\n<h5>And A Whole Lot More!</h5>\n<h2>What It Does</h2>\n<p><strong>Process</strong></p>\n<h5>Ubuntu</h5>\n<ul>\n<li>\n<p>make-script.sh </p>\n<ul>\n<li>creates a bash script to reinstall the PPAs installed </li>\n<li>creates a text file with the names of the installed packages (called the manifest)</li>\n<li>creates an array of the names of those packages stripped of extra information (using regular expressions)</li>\n<li>creates a file (with a proper shebang) to add package install dialog to</li>\n<li>adds each package name to a line starting with “sudo apt-get install -y”</li>\n<li>creates a file with both the PPAs and Packages on them for a single install scripts </li>\n<li>moves the generated install scripts and manifest to a new directory </li>\n<li>creates a tarball out of the directory</li>\n<li>cleans up</li>\n</ul>\n</li>\n</ul>\n<h2>Built With</h2>\n<p>This project was built with just BASH scripts and was a short detour into understanding more about Regular Expressions. Being motivated by a desire to simplify a process, which is of particular frustration due to the nebulous nature of Ubuntu (my primary OS when I wrote this originally), there was no GUI generated or even CLI echo statements. </p>\n<h2>Landing Page</h2>\n<p>The landing page is an early example of me using effects in SCSS, which at the time it was written I was only beginning to dabble in the use of, it is not an interactive or featureful site but serves the purpose of giving the project some web presence and as a playground served its function. </p>\n<h2>To Do</h2>\n<p>[x] create a landing page\n[ ] create echo statements enabling determination of where in the process the script is or failed\n[ ] create a GUI to confirm the process and output to the user where the scripts where saved</p>","frontmatter":{"title":"Decommissioner","date":"July 05, 2019","description":"BASH-Inception. A script for Ubuntu-based systems that generates installation scripts based on a system's currently installed packages and PPAs."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/Decommisioner/","previous":null,"next":{"fields":{"slug":"/Opitx Documentation/"},"frontmatter":{"title":"Opitx Documentation Site"}}}}}